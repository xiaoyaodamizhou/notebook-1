# 本次讲解CPU调度常见概念，CPU调度算法以及特点

cpu调度决策发生的情况：
'''
（就绪状态 <- 运行状态 <-> 等待状态）
a 当一个进程从运行态到等待状态 (请求)
b 运行状态到就绪状态 （中断）
c 等待状态到运行态
d 一个进程终止

b&c是抢占，a&d是非抢占
'''

调度准则：
```
cpu使用率： cpu利用时间 / 开机运行时间
吞吐量 （单位时间内可以完成的进程数量）
周转时间 （进程提交到完成所需要的总时间）
等待时间 （进程在就绪队列中等待所花费的总时间）
响应时间 （提交请求道第一响应的时间）

带权周转时间是指作业周转时间与作业实际运行时间的比值
带权周转时间 = 作业周转时间 / 作业实际运行时间
```

调度算法：
1， 先到先服务（FCFS）：
```
处于就绪态的进程按先后顺序链入到就绪队列中，
而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行
直到此进程阻塞或结束，才进行下一次的进程选择调度。
FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机
就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。
```

2， 最短作业优先调度（SJF）：
```
短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法
短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，
将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，
将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

（1）SRTF抢占式：又称最短剩余优先，当新进来的进程的CPU区间比当前执行的进程所剩的CPU区间短，则抢占。

（2）非抢占：称为下一个最短优先，因为在就绪队列中选择最短CPU区间的进程放在队头。

SJF调度算法的特点是吞吐率高，平均等待时间、平均周转时间最少；但算法对长作业十分不利，也完全未考虑作业的紧迫程度。
```

3， 优先级调度
4， 时间片轮转调度（RR）
```
适用于分时系统，系统将所有的就绪进程按照到达时间的先后顺序排成一个队列
进程调度程序总是选择就绪队列中第一个进程执行，即先到先服务的原则。
但仅能运行一个时间片。在使用完第一个时间片后，即使进程并没完成其运行
他也必须释放出处理机给下一个就绪的进程。而被捕哦多的进程返回到就绪队列
的末尾重新排队，等待再次运行。

在时间片轮转调度算法中，时间片的大小对系统性能的影响很大，如果时间足够大。
则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大

时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。

时间片q = 系统对相应时间的要求RT / 最大进程数N

（经验表明，时间片的取值，应该使得80%的进程在时间内完成所需的一次CPU运行活动。）

```
5， 多级反馈队列调度（MLFQ）
```
设置多个就绪队列，并为各个队列赋予不同的优先级。
第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。
仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行
在优先级越高的队列中，每个进程的执行时间片就越小或越大


当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，
按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成
，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。
如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，
可使用FCFS或RR调度算法来运行处于此队列中的进程。

如果处理机正在第i（i>1）队列中为某进程服务时，
又有新进程进入第k（k<i）的队列，则新进程将抢占正在运行进程的处理机，
即由调度程序把正在执行进程放回第i队列末尾，
重新将处理机分配给处于第k队列的新进程。
```
```
假设系统中有3个反馈队列Q1,Q2,Q3，时间片分别为2，4，8。 [1]
设有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。
1、时刻0 J1到达。于是进入到队列1 ， 运行1个时间片 ， 时间片还未到，此时J2到达。
2、时刻1 J2到达。 由于同一队列采用先来先服务，于是J2等待。 J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。当前处理机分配给J2。
3、时刻2 J1进入Q2等待调度，J2获得CPU开始运行。
4、时刻3 J3到达，由于同一队列采用先来先服务，故J3在Q1等待调度，J1也在Q2等待调度。
5、时刻4 J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待。
6、时刻5 J3经过1个时间片，完成。
7、时刻6 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束。
```